---
const { title, content, list } = Astro.props;
---

<div
  class='bg-[#282828B2] rounded-[20px] lg:rounded-4xl relative flex flex-col 4 card shrink-0 dark-btn-shadow dropdown-bg dropdown-shadow-button
  experience-card
  hover:bg-linear-to-br! from-[#e6862466] via-transparent to-[#e6862466] select-none card-animate-on-touch'
>
  <div
    class='w-full h-full rounded-[20px] bg-[#1c1c1c] lg:rounded-4xl
    px-2.25 pt-2.25 lg:px-3.5 lg:pt-3.5 2xl:pt-4! 2xl:px-4! gap-2 lg:gap-3 xl:gap-4! flex flex-col dark-btn-shadow dropdown-bg dropdown-shadow-button'
  >
    <canvas
      class='md:h-26 lg:h-28 2xl:h-44.75! w-fit h-25 pt-1 pb-2 pl-3'
      height='510'
      width='540'
    ></canvas>
    <div
      class='w-full text-white flex flex-col justify-end gap-2.5 h-fit p-1 sm:p-4'
    >
      <h3
        class='font-medium text-[14px] lg:text-[16px] xl:text-[19px]! capitalize'
      >
        {title}
      </h3>
      <p
        class='opacity-70 text-[13px] lg:text-[14px] xl:text-[16px]! grow shrink-0'
      >
        {content}
      </p>
      <ul
        class='text-white list-disc pl-4 sm:pl-3 xl:pl-3 font-medium flex flex-col gap-2 text-[14px] lg:text-[14px] 2xl:text-[18px]! grow'
      >
        {
          list?.map((data: unknown) => {
            return <li>{data}</li>;
          })
        }
      </ul>
    </div>
  </div>
</div>

<style>
  @media screen and (max-width: 330px) {
    .experience-card {
      max-width: 270px;
    }
  }
  @media screen and (min-width: 331px) and (max-width: 380px) {
    .experience-card {
      max-width: 270px;
    }
  }
  @media screen and (min-width: 381px) and (max-width: 430px) {
    .experience-card {
      max-width: 310px;
    }
  }
  @media screen and (min-width: 431px) and (max-width: 768px) {
    .experience-card {
      max-width: 300px;
    }
  }
  @media screen and (min-width: 769px) and (max-width: 830px) {
    .experience-card {
      max-width: 330px;
    }
  }
  @media screen and (min-width: 831px) and (max-width: 920px) {
    .experience-card {
      max-width: 370px;
    }
  }
  @media screen and (min-width: 921px) and (max-width: 1024px) {
    .experience-card {
      max-width: 400px;
    }
  }
  @media screen and (min-width: 1025px) and (max-width: 1279px) {
    .experience-card {
      max-width: 345px;
    }
  }
  @media screen and (min-width: 1280px) and (max-width: 1439px) {
    .experience-card {
      max-width: 330px;
    }
  }
  @media screen and (min-width: 1440px) {
    .experience-card {
      max-width: 450px;
    }
  }
</style>
<script>
  const cards = document.querySelectorAll(".experience-card");

  const imagePaths = [
    { name: "healthcare", imageCount: 60 },
    { name: "e-commerce", imageCount: 70 },
    { name: "sports", imageCount: 40 },
    { name: "business-solutions", imageCount: 100 },
    { name: "on-demand-solutions", imageCount: 60 },
  ];

  const currentFrame = (index, path) => {
    return `industries/${path}/${index.toString().padStart(4, "0")}.webp`;
  };

  cards.forEach((card, index) => {
    const { name, imageCount } = imagePaths[index];

    const canvas = card.querySelector("canvas") as HTMLCanvasElement;
    const ctx = canvas.getContext("2d");

    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    let images: any = [];
    let frame = 0;
    let animationId: null | number = null;

    let isLoaded = false;
    let isAnimating = false;
    let isHovering = false;
    let hasPlayedForward = false;

    const preloadImages = () => {
      const promises: any = [];

      for (let i = 1; i <= imageCount; i++) {
        const img = new Image();
        img.src = currentFrame(i, name);
        images.push(img);

        promises.push(
          new Promise((resolve) => {
            img.onload = resolve;
            img.onerror = resolve;
          }),
        );
      }

      Promise.all(promises).then(() => {
        isLoaded = true;
        ctx?.drawImage(images[0], 0, 0, canvas.width, canvas.height);
      });
    };

    preloadImages();

    const animateForward = () => {
      if (!isLoaded) return;

      isAnimating = true;

      ctx?.clearRect(0, 0, canvas.width, canvas.height);
      ctx?.drawImage(images[frame], 0, 0, canvas.width, canvas.height);

      if (frame < imageCount - 1) {
        frame++;
        animationId = requestAnimationFrame(animateForward);
      } else {
        hasPlayedForward = true;
        isAnimating = false;

        if (!isHovering) {
          animateReverse();
        }
      }
    };

    const animateReverse = () => {
      if (!isLoaded) return;

      isAnimating = true;

      ctx?.clearRect(0, 0, canvas.width, canvas.height);
      ctx?.drawImage(images[frame], 0, 0, canvas.width, canvas.height);

      if (frame > 0) {
        frame--;
        animationId = requestAnimationFrame(animateReverse);
      } else {
        hasPlayedForward = false;
        isAnimating = false;
      }
    };

    card.addEventListener("mouseenter", () => {
      isHovering = true;

      if (!isAnimating && !hasPlayedForward) {
        animateForward();
      }
    });
    card.addEventListener("touchstart", () => {
      isHovering = true;

      if (!isAnimating && !hasPlayedForward) {
        animateForward();
      }
    });
    card.addEventListener("touchend", () => {
      isHovering = false;

      if (!isAnimating && hasPlayedForward) {
        animateReverse();
      }
    });

    card.addEventListener("mouseleave", () => {
      isHovering = false;

      if (!isAnimating && hasPlayedForward) {
        animateReverse();
      }
    });
  });
</script>
