---
const { title, content } = Astro.props;
---

<div
  class=`w-auto xxl:max-w-[544px] h-full hover:bg-linear-to-br! from-[#e6862466] via-transparent to-[#e6862466] rounded-[20px] lg:rounded-4xl relative flex flex-col justify-center card card-animate ${title} feature-card dark-btn-shadow dropdown-bg dropdown-shadow-button border-2 border-[#151515]`
  data-name={title}
>
  <div
    class='w-full h-full rounded-[20px] bg-[#1c1c1c] lg:rounded-4xl dark-btn-shadow dropdown-bg dropdown-shadow-button'
  >
    <div class='relative z-50'>
      <div
        class='absolute flex justify-center items-center w-full pointer-events-none xl:h-57.75 -translate-y-[38%] md:-translate-y-[36%] lg:-translate-y-[38%] -translate-x-[2%] sm:-translate-x-[4%]'
      >
        <canvas
          class='xl:h-57.75 xl:w-57.75 lg:h-43.75 lg:w-43.75 md:w-36.75 md:h-36.75 h-49 relative z-50'
          height='300'
          width='300'
        ></canvas>
      </div>
    </div>
    <div
      class='pt-26 p-2.25 lg:px-3.5 xl:px-4 pb-3.5 lg:pb-5.75 xl:pb-8 flex flex-col gap-2 lg:gap-3 xl:gap-3.5 grow'
    >
      <span
        class='text-white block relative text-[14px] lg:text-[20px] xl:text-[26px] pt-4 lg:pt-5 xl:pt-7 font-medium font-poppins capitalize hero-heading'
        >{title}</span
      >
      <p
        class='text-[#F8F8F8B2] text-[12px] lg:text-[14px] xl:text-[16px] leading-4 lg:leading-5 xl:leading-6'
      >
        {content}
      </p>
    </div>
  </div>
</div>

<!-- <script>
  const cards = document.querySelectorAll(".feature-card");
  let mouseLeave = false;
  let isComplete = false;
  let running = false;
  const imagePaths = [
    "design-animation",
    "develop-animation",
    "grow-animation",
  ];
  const currentFrame = (index: number, path: string) => {
    return `/core-services/${path}/${index.toString().padStart(4, "0")}.webp`;
  };

  const img = new Image();
  // pass different attribute name to update function.

  const updateImage = (i: number, path: string, ctx: any, name: any) => {
    if (i > 30) {
      isComplete = true;
      running = false;
      if (mouseLeave) updateImageWhenLeave(30, path, ctx, name);
      return;
    }
    running = true;
    img.src = currentFrame(i, path);

    img.onload = () => {
      ctx?.clearRect(0, 0, 300, 300);
      ctx?.drawImage(img, 0, 0, 300, 300);

      requestAnimationFrame(() => updateImage(i + 1, path, ctx, name));
    };
  };

  const updateImageWhenLeave = (
    i: number,
    path: string,
    ctx: any,
    name: any,
  ) => {
    if (i < 1) {
      isComplete = false;
      running = false;
      return;
    }
    img.src = currentFrame(i, path);
    running = true;
    img.onload = () => {
      ctx?.clearRect(0, 0, 300, 300);
      ctx?.drawImage(img, 0, 0, 300, 300);

      requestAnimationFrame(() => updateImageWhenLeave(i - 1, path, ctx, name));
    };
  };

  // Render only first image when page loads.
  cards.forEach((card, index) => {
    const img = new Image();
    img.src = currentFrame(1, imagePaths[index]);
    img.onload = () => {
      const canvas = card.children[0].children[0].children[0]
        .children[0] as any;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, 300, 300);
    };
  });

  cards.forEach((card, index) => {
    card.addEventListener("mouseenter", () => {
      mouseLeave = false;

      const canvas = card.children[0].children[0].children[0]
        .children[0] as any;
      const ctx = canvas.getContext("2d");
      if (!running) updateImage(1, imagePaths[index], ctx, card.dataset.name);
    });
    card.addEventListener("mouseleave", () => {
      mouseLeave = true;

      const canvas = card.children[0].children[0].children[0]
        .children[0] as any;
      const ctx = canvas.getContext("2d");
      if (!running)
        updateImageWhenLeave(30, imagePaths[index], ctx, card.dataset.name);
    });
  });
</script> -->

<script>
  import gsap from "gsap";

  const cards = document.querySelectorAll(".feature-card");
  const imagePaths = [
    "design-animation",
    "develop-animation",
    "grow-animation",
  ];

  cards.forEach((card, index) => {
    // 1. Target Canvas and Context
    const canvas = card.querySelector("canvas");
    const ctx = canvas?.getContext("2d");
    const path = imagePaths[index];

    // Configuration
    const config = {
      frameCount: 30,
      duration: 0.5,
    };

    // 2. Card-Specific State
    const state = { frame: 0 };
    const status = {
      isHovering: false,
      isLeaving: false,
    };

    let hoverAnimation = null;
    let leaveAnimation = null;

    // 3. Preload Images
    const images = [];
    for (let i = 0; i < config.frameCount; i++) {
      const img = new Image();
      img.src = `/core-services/${path}/${(i + 1).toString().padStart(4, "0")}.webp`;
      images.push(img);
    }

    // Render Function
    const render = () => {
      const frameIndex = Math.round(state.frame);
      if (images[frameIndex] && ctx) {
        ctx.clearRect(0, 0, 300, 300);
        ctx.drawImage(images[frameIndex], 0, 0, 300, 300);
      }
    };

    // Initial Draw
    images[0].onload = render;

    // 4. Animation Logic
    const startHoverAnimation = () => {
      if (hoverAnimation) hoverAnimation.kill();

      status.isHovering = true;
      hoverAnimation = gsap.to(state, {
        frame: config.frameCount - 1,
        snap: "frame",
        ease: "none",
        duration: config.duration,
        onUpdate: render,
        onComplete: () => {
          status.isHovering = false;
          // If the user moved their mouse out while this was playing
          if (card.dataset.pendingLeave === "true") {
            card.dataset.pendingLeave = "false";
            startLeaveAnimation();
          }
        },
      });
    };

    const startLeaveAnimation = () => {
      if (leaveAnimation) leaveAnimation.kill();

      status.isLeaving = true;
      leaveAnimation = gsap.to(state, {
        frame: 0,
        snap: "frame",
        ease: "none",
        duration: config.duration,
        onUpdate: render,
        onComplete: () => {
          status.isLeaving = false;
          // If the user moved their mouse back in while this was playing
          if (card.dataset.pendingHover === "true") {
            card.dataset.pendingHover = "false";
            startHoverAnimation();
          }
        },
      });
    };

    // 5. Event Handlers
    const handleMouseEnter = () => {
      card.dataset.pendingHover = "true";
      card.dataset.pendingLeave = "false";

      if (status.isLeaving) {
        // Wait for leave to finish
        leaveAnimation.eventCallback("onComplete", () => {
          if (card.dataset.pendingHover === "true") {
            card.dataset.pendingHover = "false";
            startHoverAnimation();
          }
        });
      } else if (!status.isHovering) {
        card.dataset.pendingHover = "false";
        startHoverAnimation();
      }
    };

    const handleMouseLeave = () => {
      card.dataset.pendingLeave = "true";
      card.dataset.pendingHover = "false";

      if (status.isHovering) {
        // Wait for hover to finish
        hoverAnimation.eventCallback("onComplete", () => {
          if (card.dataset.pendingLeave === "true") {
            card.dataset.pendingLeave = "false";
            startLeaveAnimation();
          }
        });
      } else if (!status.isLeaving) {
        card.dataset.pendingLeave = "false";
        startLeaveAnimation();
      }
    };

    card.addEventListener("mouseenter", handleMouseEnter);
    card.addEventListener("mouseleave", handleMouseLeave);
  });
</script>
