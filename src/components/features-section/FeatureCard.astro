---
const { title, content } = Astro.props;
---

<div
  class=`w-auto xxl:max-w-[544px] h-full hover:bg-linear-to-br! from-[#e6862466] via-transparent to-[#e6862466] rounded-[20px] lg:rounded-4xl relative flex flex-col justify-center card card-animate ${title} feature-card dark-btn-shadow  dropdown-bg dropdown-shadow-button border-2 border-[#151515] card-animate-on-touch grayscale transition-all duration-500`
  data-name={title}
>
  <div
    class='w-full h-full rounded-[20px] bg-[#1c1c1c] lg:rounded-4xl dark-btn-shadow dropdown-bg dropdown-shadow-button'
  >
    <div class='relative z-100'>
      <div
        class='absolute flex justify-center items-center w-full pointer-events-none xl:h-57.75 -translate-y-[38%] md:-translate-y-[36%] lg:-translate-y-[38%] -translate-x-[2%] sm:-translate-x-[4%]'
      >
        <canvas
          class='xl:h-57.75 xl:w-57.75 lg:h-43.75 lg:w-43.75 md:w-36.75 md:h-36.75 h-49 relative z-50'
          height='300'
          width='300'
        ></canvas>
      </div>
    </div>
    <div
      class='pt-26 p-2.25 lg:px-3.5 xl:px-4 pb-3.5 lg:pb-5.75 xl:pb-8 flex flex-col gap-2 lg:gap-3 xl:gap-3.5 grow'
    >
      <span
        class='text-white block relative text-[14px] lg:text-[20px] xl:text-[26px] pt-4 lg:pt-5 xl:pt-7 font-medium font-poppins capitalize hero-heading'
        >{title}</span
      >
      <p
        class='text-[#F8F8F8B2] text-[12px] lg:text-[14px] xl:text-[16px] leading-4 lg:leading-5 xl:leading-6'
      >
        {content}
      </p>
    </div>
  </div>
</div>

<script>
  const cards = document.querySelectorAll(".feature-card");

  const imagePaths = [
    "design-animation",
    "develop-animation",
    "grow-animation",
  ];

  const FRAME_COUNT = 30;
  const WIDTH = 300;
  const HEIGHT = 300;

  const currentFrame = (index, path) => {
    return `/core-services/${path}/${index.toString().padStart(4, "0")}.webp`;
  };

  cards.forEach((card, index) => {
    const path = imagePaths[index];
    const canvas = card.querySelector("canvas") as any;
    const ctx = canvas.getContext("2d");

    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    let images: any = [];
    let frame = 0;
    let animationId: null | number = null;

    let isLoaded = false;
    let isAnimating = false;

    let isHovering = false;
    let hasPlayedForward = false;

    const preloadImages = () => {
      const promises: any = [];

      for (let i = 1; i <= FRAME_COUNT; i++) {
        const img = new Image();
        img.src = currentFrame(i, path);
        images.push(img);

        promises.push(
          new Promise((resolve) => {
            img.onload = resolve;
            img.onerror = resolve;
          }),
        );
      }

      Promise.all(promises).then(() => {
        isLoaded = true;
        ctx.drawImage(images[0], 0, 0, WIDTH, HEIGHT);
      });
    };

    preloadImages();

    const animateForward = () => {
      if (!isLoaded) return;

      isAnimating = true;

      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      ctx.drawImage(images[frame], 0, 0, WIDTH, HEIGHT);

      if (frame < FRAME_COUNT - 1) {
        frame++;
        animationId = requestAnimationFrame(animateForward);
      } else {
        hasPlayedForward = true;
        isAnimating = false;

        if (!isHovering) {
          animateReverse();
        }
      }
    };

    const animateReverse = () => {
      if (!isLoaded) return;

      isAnimating = true;

      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      ctx.drawImage(images[frame], 0, 0, WIDTH, HEIGHT);

      if (frame > 0) {
        frame--;
        animationId = requestAnimationFrame(animateReverse);
      } else {
        hasPlayedForward = false;
        isAnimating = false;
      }
    };

    card.addEventListener("touchstart", () => {
      isHovering = true;

      if (!isAnimating && !hasPlayedForward) {
        animateForward();
      }
    });
    card.addEventListener("mouseenter", () => {
      isHovering = true;

      if (!isAnimating && !hasPlayedForward) {
        animateForward();
      }
    });

    card.addEventListener("touchend", () => {
      isHovering = false;

      if (!isAnimating && hasPlayedForward) {
        animateReverse();
      }
    });
    card.addEventListener("mouseleave", () => {
      isHovering = false;

      if (!isAnimating && hasPlayedForward) {
        animateReverse();
      }
    });
  });
</script>
